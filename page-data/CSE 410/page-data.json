{
    "componentChunkName": "component---node-modules-gatsby-theme-kb-src-templates-topic-js",
    "path": "/CSE 410",
    "result": {"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Themes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Simpler is Faster\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Static vs. Dynamic Evaluation\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Representation and Translation\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Interfaces vs. Implementation\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Layers, not options\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Policy vs. mechanism\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Interposition to evolve functionality\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Naming / Virtualization\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Parallelism / Concurrency\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Trading space for time\")), mdx(\"h2\", null, \"Simpler is Faster\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"RISC-V ISA\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"load-store architecture (all operations are on values in registers)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"instructions are all 32 bits long (vs. variable length instructions)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"simple operations (load, store, add, and, shift, branch, jal, etc.)\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"no hardware notion of stack\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"no hardware notion of procedure call (beyond jal instruction)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"no hareware notion of type\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Languages\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"C vs. Java (functionality / performance)\")))), mdx(\"h3\", null, \"Layering\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"OS over hardware\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"abstracts memory to address space\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"abstracts processor to thread\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"abstracts disk to file system\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"abstracts network to sockets / connections\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Virtual memory\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Hardware provides mechanism ( address translation and page faults)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"OS provides policy (management of physical memory, setting access rights in virtual memory)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Language over ISA / OS abstractions\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"programmer works to language specifications, not ISA / OS specifications  \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"more efficient for programmer\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"portable across ISAs\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ISA over hardware\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"hardware is boolean circuits, ISA is an interface specifications\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Caches / Memory Hierarchy\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Main memory cache\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Small / fast\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Transparent\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Registers\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"a \\\"programmer controlled cache\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"pushes issue of deciding which values are most important right now to the compiler (see Static vs. Dynamic)\")))), mdx(\"h2\", null, \"Static vs. Dynamic\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We often prefer to do things statically - at compile / build time - because then we don't pay the cost of doing it at each execution\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type checking\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Additionally, we can \\\"view the entire program\\\" statically, whereas we see only the current instruction at run time\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Compiler can perform optimizations statically that you couldn't perform dynamically\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dead code removal\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Some things can be done only dynamically\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Optimizating instruction sequences across brances \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Inserting bubbles in pipeline when needed, but only when needed\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All computations / optimizations involving input\")))), mdx(\"h2\", null, \"Representation and Translation\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Everything is bits\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Why base 2? Why not base 3?\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Intergers\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"signed and unsigned (why?)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"overflow\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Floats\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Characters\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Strings\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"instructions\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Want compact encoding of instructions. Why?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Must be able to encode every possible instruction\")))), mdx(\"h3\", null, \"Instructions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Instruction formats\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Why have an immediate format instruction?\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The instruction operand is ready as soon as the instruction has been decoded, instead of having to wait for the result of a previous memory load instruction.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Why base-displacement memory addressing?\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Every address is shorter\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Addresses become correct no matter where the program is loaded in memory\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"PC relative branch format\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"branch range center around PC\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Assembly language\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"human readable\\\" assembly language\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Role of the assembler\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What does it do, what doesn't it do (compared with a compiler)?\")))))), mdx(\"h2\", null, \"Interfaces vs. Implementations\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ISA as an interface\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"One-at-a-time instruction execution model\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pipelining as an Implementation\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Many instructions in execution at once (Instruction Level Parallelism)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pipelining is made more effective by careful design of the ISA (RISC-V)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pipeline hazards\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Load hazards\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Control hazards\")))), mdx(\"h2\", null, \"Layers, Not options\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Programs on top of compilers on top of OS on top of hardware\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"User level threads on top of kernel threads\")), mdx(\"h2\", null, \"Policy vs. mechanism\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Example\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mechanism: trap handler mechanism\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Policy: what ever OS decides to do in response\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Example\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Signals\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Policy: whatever app decides to do in response\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The most general way to defer policy to a layer above is to allow that layer to execute code when an event that requires a policy decision occurs\")), mdx(\"h2\", null, \"Interposition / Naming\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Interposition is finding an existing interface and inserting new functionality that conforms to the existing interface\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Example\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Main memory Caches\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Virtual Memory\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Copy-on-write fork()\")))), mdx(\"h2\", null, \"Parallelism / Concurrency\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Instruction level Parallelism\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pipelines\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Processes\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"More than one application running concurrently\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Threads\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A single application using more than one core concurrently\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A single application dividing it's control flow into simple, relatively independent paths\")))), mdx(\"h2\", null, \"Trading Space for time\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Caches\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"More space, less time\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Virtual Memory\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Less space, more time\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pipelines\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"More space, less time\")))), mdx(\"h1\", null, \"Skills\"), mdx(\"h2\", null, \"Compile\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Compile C-like code to RISC-V assembler\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Decompile RISC-V assembler to C-like code\")), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"c++\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-c++\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c++\"\n  }, \"int sub(int *P0, int P1) {\\n  int L1 = 0;\\n  for (int L0 = 0; L0 < P1; L0++) {\\n    if (20480 - 481 < L1) {\\n      return L1;\\n    }\\n    L1 += P0[L0];\\n  }\\n}\"))), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"sub:\\n    addi    sp,sp,-48       // sp = sp + 48\\n    sw      s0,44(sp)       // s0 -> 44(sp)\\n    addi    s0,sp,48        // s0 = sp + 48\\n    sw      a0,-36(s0)      // save fn args / return vals to -36(s0)\\n    sw      a1,-40(s0)      // save fn args / return vals to -40(s0)\\n    sw      zero,-24(s0)    // 0 -> -24(s0)\\n    sw      zero,-20(s0)    // 0 -> -20(s0)\\n    jal     x0,.L2          // x0 = PC + 4, PC += imm\\n.L4:\\n    lw      a5,-20(s0)      // a5 <- -20(s0)\\n    slli    a5,a5,2         // a5 = a5 << 2\\n    lw      a4,-36(s0)      // a4 <- -36(s0) \\n    add     a5,a4,a5        // a5 = a4 + a5\\n    lw      a5,0(a5)        // a5 <- 0(a5)\\n    lw      a4,-24(s0)      // a4 <- -24(s0)\\n    add     a5,a4,a5        // a5 = a4 + a5\\n    sw      a5,-24(s0)      // a5 -> -24(s0)\\n    lw      a5,-20(s0)      // a5 <- -20(s0)\\n    addi    a5,a5,1         // a5 = a5 + 1\\n    sw      a5,-20(s0)      // a5 -> -20(s0)\\n.L2:\\n    lw      a4,-20(s0)      // a4 <- -20(s0)\\n    lw      a5,-40(s0)      // a5 <- -40(s0)\\n    bge     a4,a5,.L3       // a4 >= a5 ? .L3 : nop\\n    lw      a4,-24(s0)      // a4 <- -24(s0)\\n    addi    a5,x0, 20480    // a5 = 0 + 20480\\n    addi    a5,a5,-481      // a5 = a5 + -481\\n    bge     a5, a4, .L4     // a5 >= a4 ? .L4 : nop\\n.L3:\\n    lw      a5,-24(s0)      // a5 <- -24(s0)\\n    addi    a0, a5, 0       // a0 = a5 + 0\\n    lw      s0,44(sp)       // s0 -> 44(sp)\\n    addi    sp,sp,48        // sp = sp + 48\\n    jalr    x0, ra, 0       // x0 += 4, PC = ra + 0\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Encode / Decode RISC-V assembler / machine instructions\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Manually simulate the result of executing a RISC-V assembler\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Follow subroutine calling conventions in RISC-V assembler to call a function and to return a value from function to the caller\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Including caller/callee saved registers\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Manuall optimize a sequence of assembler instructions by re-writing them to an equivalnet sequence that runs in fewer cycles\")), mdx(\"h2\", null, \"Boolean circuits\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can define truth tables for a Boolean function\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can convert a truth table into a Boolean circuit\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can convert a Boolean circuit into a truth table\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understand how Boolean circuits can do binary addition\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"half-adders and full-adders\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"\"\n  }, \"half-adder\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"\"\n  }, \"full-adder\"))))), mdx(\"h2\", null, \"Machine Organziation\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Determin how many cycles it will take to issue a sequence of RISC-V instructions into the standard five stage pipeline\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Including dealing with control and load hazards when the pipeline implements forwarding\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Determine the RAW, WAW, and WAR dependences that limit possible parallel execution of a sequence of instructions\")), mdx(\"h2\", null, \"Caches\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understand when caches will be effective\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Temporal and spatial locality\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Informally evaluate code in terms of how much spatial and / or temporal locality it has\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Apply some simple re-writes to code to improve it's spatial and / or temporal locality\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We used block matrix multiply as an example in class\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Given a cache design (block / cache line size, number of lines, and set associativity) and a memory address, determine where in the cache to look for a possibly cached copy of the value stored at that address\")), mdx(\"h2\", null, \"OS / Security\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understand the mechanism the OS uses to protect the CPU\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understand the mechanism the OS uses to protect I/O devices\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understand the mechanism the OS uses to protect memory\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Be able to explain how the OS on klaatu keeps your from running a program that reads private files owned by other users\")), mdx(\"h2\", null, \"OS / Processes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understand fork / exec\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What they do\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fork: Making a copy of parent process (the copy is now the child) \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Exec: Run the program provided in a process\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Why giving a chance for the parent's code to run in the context of the child's process is a good idea\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How is \\\"inheritance\\\" used (and useful) in fork()?\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understand / write code for a simple shell that does input / output redirection or creates pipes between Processes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understand how it is that the OS protects\")), mdx(\"h2\", null, \"Virtual Memory\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understand the mechanism\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Address translation: mapping from a virtual address to a physical address through a page table\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Finding the page table index to locate a page table entry\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Checking the valid bit\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Extracting the physical frame number\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Combining it with the offset from the address to create the physical address\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Page faults\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"because the valid bit is false\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"because the page table entry doesn't permit access of the type being attempted (read, write, execute)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Holes in the virtual address space\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Why?\")))), mdx(\"h2\", null, \"Processes / Address Spaces\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How do you create a process?\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What has to happen to create a process?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What doesn't happen?\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Role of exec()\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Memory layout for process address space\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Stack / heap / static data / text\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Permissions for each section of the address space\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Process control blocks and process state\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Running / runnable / blocked\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The context switch mechanism\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Why must the hardware save the PC at the time of an interrupt / trap / exception? Why can't the software do it?\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Copy on write\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What is it used for?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How does it work?\")))), mdx(\"h2\", null, \"Threads\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Why arent' processes enough?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Creating a thread (in Java)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"join()'ing with a thread\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Why use both kernel threads and user level threads?\")), mdx(\"h2\", null, \"Threads / Synchronization\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Recognizing code that has a race condition\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Recognizing code that is a critical section\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"And code that isn't\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Resolving critical sections through mutual exclusion\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In general, using locks\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In Java, using \\\"synchronized\\\" methods\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Recognizing when deadlock might occur\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can multiple processes have arace condition (among them)? Can they deadlock?\")), mdx(\"h2\", null, \"Limits to Parallelism / Concurrency\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Number of cores on system\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Number of threads in the application\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Depth of pipeline\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dependences among instructions (RAW, WAW, WAR)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Amdahl's Law\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"tableOfContents":{"items":[{"url":"#themes","title":"Themes","items":[{"url":"#simpler-is-faster","title":"Simpler is Faster","items":[{"url":"#layering","title":"Layering"}]},{"url":"#static-vs-dynamic","title":"Static vs. Dynamic"},{"url":"#representation-and-translation","title":"Representation and Translation","items":[{"url":"#instructions","title":"Instructions"}]},{"url":"#interfaces-vs-implementations","title":"Interfaces vs. Implementations"},{"url":"#layers-not-options","title":"Layers, Not options"},{"url":"#policy-vs-mechanism","title":"Policy vs. mechanism"},{"url":"#interposition--naming","title":"Interposition / Naming"},{"url":"#parallelism--concurrency","title":"Parallelism / Concurrency"},{"url":"#trading-space-for-time","title":"Trading Space for time"}]},{"url":"#skills","title":"Skills","items":[{"url":"#compile","title":"Compile"},{"url":"#boolean-circuits","title":"Boolean circuits"},{"url":"#machine-organziation","title":"Machine Organziation"},{"url":"#caches","title":"Caches"},{"url":"#os--security","title":"OS / Security"},{"url":"#os--processes","title":"OS / Processes"},{"url":"#virtual-memory","title":"Virtual Memory"},{"url":"#processes--address-spaces","title":"Processes / Address Spaces"},{"url":"#threads","title":"Threads"},{"url":"#threads--synchronization","title":"Threads / Synchronization"},{"url":"#limits-to-parallelism--concurrency","title":"Limits to Parallelism / Concurrency"}]}]},"outboundReferences":[],"inboundReferences":[]},"fields":{"slug":"/CSE 410","title":"Themes"}}},"pageContext":{"id":"54843616-72cd-5207-a620-763cabc58e81","refWordMdxSlugDict":{},"tocTypes":["sidebar"]}},
    "staticQueryHashes": ["2221750479","2380733210","2768355698","63159454","847517413"]}